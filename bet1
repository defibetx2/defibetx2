pragma solidity >=0.7.0 <0.9.0;

contract DefiBetX2_1e{
    mapping(address=>gamble[]) public gambleList; //lists of gambles by address
    mapping(address=>uint) gambleCount; //number of gambles by account
    mapping(address=>bool)  state1; //indicates if the address already has a bet
    address burn=0x000000000000000000000000000000000000dEaD; //burn address on ethereum used to fill the first places on the arrays
    address[]  high1; //List of address betting high
    address[]  low1; //List of address betting low
    uint ammount1 = 1 ether; //the bet
    address payable owner; // the owner of this contract
    uint index1; //current bet being played
    uint highIndex1; //indicates how many address are betting high
    uint lowIndex1; //indicates how many address are betting low
    uint withdrawableAmmount= 0 ether; //earnings of the owner
    
    struct gamble{
        address player;
        address opponent;
        uint bet;
        string choice;
        address winner;
    }
    
    modifier onlyOwner(){
        require(msg.sender==owner);
        _;
    }
    
    constructor(){
        owner=payable(msg.sender);
        index1=1;
        highIndex1= 1;
        lowIndex1= 1;
        high1.push(burn);
        low1.push(burn);
    }

    function enterHigh1() external payable returns(uint){
        require(msg.value== ammount1 && state1[msg.sender]==false); //verifying if the ammount is correct and if they dont have anothe ber in this category
        state1[msg.sender]=true;
        high1.push(msg.sender);
        highIndex1++;
        gambleCount[msg.sender]++;
        return play1();
    }
    
    function enterLow1() external payable returns(uint){
        require(msg.value== ammount1 && state1[msg.sender]==false); //verifying if the ammount is correct and if they dont have anothe ber in this category
        state1[msg.sender]=true;
        low1.push(msg.sender);
        lowIndex1++;
        gambleCount[msg.sender]++;
        return play1();
    }
    
    function play1() internal  returns(uint){
        uint randNumber;
        address payable winner;
        address payable refund;
        if(index1<highIndex1 && index1<lowIndex1){
            if(state1[high1[index1]]==true  && state1[low1[index1]]==true){
                randNumber=uint(keccak256(abi.encodePacked(block.timestamp, high1[index1], low1[index1])))%10;
                if(randNumber>=5){
                    winner =payable(high1[index1]);
                    gambleList[high1[index1]].push(gamble(high1[index1],low1[index1],1 ether,"high",high1[index1]));
                    gambleList[low1[index1]].push(gamble(low1[index1],high1[index1],1 ether,"low",high1[index1]));
                }
                else{
                    winner =payable(low1[index1]); 
                    gambleList[high1[index1]].push(gamble(high1[index1],low1[index1],1 ether,"high",low1[index1]));
                    gambleList[low1[index1]].push(gamble(low1[index1],high1[index1],1 ether,"low",low1[index1]));
                }
            
                winner.transfer(1.936 ether); //transfering funds to the winner
                withdrawableAmmount= withdrawableAmmount+ 0.064 ether;
                state1[high1[index1]]=false;//allowing player to enter another bet in this category
                state1[low1[index1]]=false;//allowing player to enter another bet in this category
                index1++;
                
            }
            
            else{
                randNumber=10;
                if(state1[high1[index1]]==true){
                    refund=payable(high1[index1]);
                    refund.transfer(1 ether);
                    state1[high1[index1]]=false;
                    gambleList[high1[index1]].push(gamble(high1[index1],low1[index1],1 ether,"opponent retired",0x000000000000000000000000000000000000dEaD));
                    gambleList[low1[index1]].push(gamble(low1[index1],high1[index1],1 ether,"you retired",0x000000000000000000000000000000000000dEaD));
                }
                if(state1[low1[index1]]==true){
                    refund=payable(low1[index1]);
                    refund.transfer(1 ether);
                    state1[low1[index1]]=false;
                    gambleList[high1[index1]].push(gamble(high1[index1],low1[index1],1 ether,"you retired",0x000000000000000000000000000000000000dEaD));
                    gambleList[low1[index1]].push(gamble(low1[index1],high1[index1],1 ether,"opponent retired",0x000000000000000000000000000000000000dEaD));
                }
                index1++;
            }
        }
        
        else{
            randNumber=11;
        }
        return randNumber;
    }
    
    function retire1() external{
        require(state1[msg.sender]==true);
        address payable quiter= payable(msg.sender);
        state1[msg.sender]=false;
        quiter.transfer(0.968 ether);
        withdrawableAmmount= withdrawableAmmount+ 0.032 ether;

    }
    
    function checkState1()external view returns (bool){
        return state1[msg.sender];
    }
    
    function withdraw() external onlyOwner{
        owner.transfer(withdrawableAmmount);
    }

    function changeOwner(address _newOwner) external onlyOwner{ //change the owner of the contract
        owner=payable(_newOwner);
    }
}
