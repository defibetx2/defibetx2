pragma solidity >=0.7.0 <0.9.0;

contract DefiBetX2_10e{
    mapping(address=>gamble[]) public gambleList; //lists of gambles by address
    mapping(address=>uint) gambleCount; //number of gambles by account
    mapping(address=>bool)  state10; //indicates if the address already has a bet
    address burn=0x000000000000000000000000000000000000dEaD; //burn address on ethereum used to fill the first places on the arrays
    address[]  high10; //List of address betting high
    address[]  low10; //List of address betting low
    uint ammount10 = 10 ether; //the bet
    address payable owner; // the owner of this contract
    uint index10; //current bet being played
    uint highIndex10; //indicates how many address are betting high
    uint lowIndex10; //indicates how many address are betting low
    uint withdrawableAmmount= 0 ether; //earnings of the owner
    
    struct gamble{
        address player;
        address opponent;
        uint bet;
        string choice;
        address winner;
    }
    
    modifier onlyOwner(){
        require(msg.sender==owner);
        _;
    }
    
    constructor(){
        owner=payable(msg.sender);
        index10=1;
        highIndex10= 1;
        lowIndex10= 1;
        high10.push(burn);
        low10.push(burn);
    }

    function enterHigh10() external payable returns(uint){
        require(msg.value== ammount10 && state10[msg.sender]==false); //verifying if the ammount is correct and if they dont have anothe ber in this category
        state10[msg.sender]=true;
        high10.push(msg.sender);
        highIndex10++;
        gambleCount[msg.sender]++;
        return play10();
    }
    
    function enterLow10() external payable returns(uint){
        require(msg.value== ammount10 && state10[msg.sender]==false); //verifying if the ammount is correct and if they dont have anothe ber in this category
        state10[msg.sender]=true;
        low10.push(msg.sender);
        lowIndex10++;
        gambleCount[msg.sender]++;
        return play10();
    }
    
    function play10() internal  returns(uint){
        uint randNumber;
        address payable winner;
        address payable refund;
        if(index10<highIndex10 && index10<lowIndex10){
            if(state10[high10[index10]]==true  && state10[low10[index10]]==true){
                randNumber=uint(keccak256(abi.encodePacked(block.timestamp, high10[index10], low10[index10])))%10;
                if(randNumber>=5){
                    winner =payable(high10[index10]);
                    gambleList[high10[index10]].push(gamble(high10[index10],low10[index10],10 ether,"high",high10[index10]));
                    gambleList[low10[index10]].push(gamble(low10[index10],high10[index10],10 ether,"low",high10[index10]));
                }
                
                else{
                    winner =payable(low10[index10]); 
                    gambleList[high10[index10]].push(gamble(high10[index10],low10[index10],10 ether,"high",low10[index10]));
                    gambleList[low10[index10]].push(gamble(low10[index10],high10[index10],10 ether,"low",low10[index10]));
                }
            
                winner.transfer(19.36 ether); //transfering funds to the winner
                withdrawableAmmount= withdrawableAmmount+ 0.64 ether;
                state10[high10[index10]]=false; //allowing player to enter another bet in this category
                state10[low10[index10]]=false; //allowing player to enter another bet in this category
                index10++;
            }
            
            else{
                randNumber=10;
                if(state10[high10[index10]]==true){
                    refund=payable(high10[index10]);
                    refund.transfer(10 ether);
                    state10[high10[index10]]=false;
                    gambleList[high10[index10]].push(gamble(high10[index10],low10[index10],10 ether,"opponent retired",0x000000000000000000000000000000000000dEaD));
                    gambleList[low10[index10]].push(gamble(low10[index10],high10[index10],10 ether,"you retired",0x000000000000000000000000000000000000dEaD));
                }
                if(state10[low10[index10]]==true){
                    refund=payable(low10[index10]);
                    refund.transfer(10 ether);
                    state10[low10[index10]]=false;
                    gambleList[high10[index10]].push(gamble(high10[index10],low10[index10],10 ether,"you retired",0x000000000000000000000000000000000000dEaD));
                    gambleList[low10[index10]].push(gamble(low10[index10],high10[index10],10 ether,"opponent retired",0x000000000000000000000000000000000000dEaD));
                }
                index10++;
            }
        }
        else{
            randNumber=11;
        }
        return randNumber;
    }
    
    function retire10() external{
        require(state10[msg.sender]==true);
        address payable quiter= payable(msg.sender);
        state10[msg.sender]=false;
        quiter.transfer(9.68 ether);
        withdrawableAmmount= withdrawableAmmount+ 0.32 ether;
    }

    function checkState10()external view returns (bool){
        return state10[msg.sender];
    }
    
    function withdraw() external onlyOwner{
        owner.transfer(withdrawableAmmount);
    }
    
    function changeOwner(address _newOwner) external onlyOwner{ //change the owner of the contract
        owner=payable(_newOwner);
    }
}
