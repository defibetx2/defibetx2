pragma solidity >=0.7.0 <0.9.0;

contract DefiBetX2_001e{
    mapping(address=>gamble[]) public gambleList; //lists of gambles by address
    mapping(address=>uint) gambleCount; //number of gambles by account
    mapping(address=>bool)  state001; //indicates if the address already has a bet
    address burn=0x000000000000000000000000000000000000dEaD; //burn address on ethereum used to fill the first places on the arrays
    address[]  high001; //List of address betting high
    address[]  low001; //List of address betting low
    uint ammount001 = 0.01 ether; //the bet
    address payable owner; // the owner of this contract
    uint index001; //current bet being played
    uint highIndex001; //indicates how many address are betting high
    uint lowIndex001; //indicates how many address are betting low
    uint withdrawableAmmount= 0 ether; //earnings of the owner
    
    struct gamble{
        address player;
        address opponent;
        uint bet;
        string choice;
        address winner;
    }
    
    modifier onlyOwner(){
        require(msg.sender==owner);
        _;
    }
    
    constructor(){
        owner=payable(msg.sender);
        index001=1;
        highIndex001= 1;
        lowIndex001= 1;
        high001.push(burn);
        low001.push(burn);
    }
    
    function enterHigh001() external payable returns(uint){
        require(msg.value== ammount001  && state001[msg.sender]==false); //verifying if the ammount is correct and if they dont have anothe ber in this category
        state001[msg.sender]=true;
        high001.push(msg.sender);
        highIndex001++;
        gambleCount[msg.sender]++;
        return play001();
    }
    
    function enterLow001() external payable returns(uint){
        require(msg.value== ammount001 && state001[msg.sender]==false); //verifying if the ammount is correct and if they dont have anothe ber in this category
        state001[msg.sender]=true;
        low001.push(msg.sender);
        lowIndex001++;
        gambleCount[msg.sender]++;
        return play001();
    }

    function play001() internal  returns(uint){
        uint randNumber;
        address payable winner;
        address payable refund;
        if(index001<highIndex001 && index001<lowIndex001){
            if(state001[high001[index001]]==true  && state001[low001[index001]]==true){
                randNumber=uint(keccak256(abi.encodePacked(block.timestamp, high001[index001], low001[index001])))%10;
                if(randNumber>=5){
                    winner =payable(high001[index001]);
                    gambleList[high001[index001]].push(gamble(high001[index001],low001[index001],0.01 ether,"high",high001[index001]));
                    gambleList[low001[index001]].push(gamble(low001[index001],high001[index001],0.01 ether,"low",high001[index001]));
            }
                 else{
                    winner =payable(low001[index001]);
                    gambleList[high001[index001]].push(gamble(high001[index001],low001[index001],0.01 ether,"high",low001[index001]));
                    gambleList[low001[index001]].push(gamble(low001[index001],high001[index001],0.01 ether,"low",low001[index001]));
                }
            
                winner.transfer(0.01936 ether); //transfering funds to the winner
                withdrawableAmmount= withdrawableAmmount+ 0.00064 ether;
                state001[high001[index001]]=false;//allowing player to enter another bet in this category
                state001[low001[index001]]=false;//allowing player to enter another bet in this category
                index001++;
                
            }
            
            else{
                randNumber=10; //el 10 significa que uno o los dos jugadores se retiraron antes de su turno
                if(state001[high001[index001]]==true){
                    state001[high001[index001]]=false;
                    refund=payable(high001[index001]);
                    refund.transfer(0.01 ether);
                    gambleList[high001[index001]].push(gamble(high001[index001],low001[index001],0.01 ether,"opponent retired",0x000000000000000000000000000000000000dEaD));
                    gambleList[low001[index001]].push(gamble(low001[index001],high001[index001],0.01 ether,"you retired",0x000000000000000000000000000000000000dEaD));
                }
                if(state001[low001[index001]]==true){
                    state001[low001[index001]]=false;
                    refund=payable(low001[index001]);
                    refund.transfer(0.01 ether);
                    gambleList[high001[index001]].push(gamble(high001[index001],low001[index001],0.01 ether,"you retired",0x000000000000000000000000000000000000dEaD));
                    gambleList[low001[index001]].push(gamble(low001[index001],high001[index001],0.01 ether,"opponent retired",0x000000000000000000000000000000000000dEaD));
                }
                
                index001++;
            }
        }
        
        else{
            randNumber=11; //el 11 significa que no hay numero de jugadores necesarios para jugar
        }
        return randNumber;
    }
   
    function retire001() external{
        require(state001[msg.sender]==true);
        address payable quiter= payable(msg.sender);
        state001[msg.sender]=false;
        quiter.transfer(0.00968 ether);
        withdrawableAmmount= withdrawableAmmount+ 0.00032 ether;
    }
    
    function checkState001()external view returns (bool){
        return state001[msg.sender];
    }
    
    function withdraw() external onlyOwner{
        owner.transfer(withdrawableAmmount);
    }
    
    function changeOwner(address _newOwner) external onlyOwner{ //change the owner of the contract
        owner=payable(_newOwner);
    }
}
